{"version":3,"sources":["srgs.js","chartparser.js","dmAppointment.ts","dmTodo.ts","dmTimer.ts","runparser.js","grammars/homeGrammar.ts","dmSmartHome.ts","dmMain.ts","grammars/funnyGrammar.ts","index.tsx"],"names":["Grammar","root","this","$root","VOID","OneOf","NULL","GARBAGE","$check","i","checkSequenceExpansion","err","throwRuleError","Ref","ref","RefClass","Tag","tag","TagClass","alternatives","OneOfClass","Repeat","min","max","sequence","RepeatClass","ruleref","content","_string","toString","join","Infinity","message","error","undefined","TypeError","constructor","Array","name","String","checkExpansion","prototype","Number","LOG","str","clone","obj","temp","key","isEmpty","ob","hasOwnProperty","Chart","numberOfWords","passives","actives","add","edge","subchart","cat","isPassive","start","lhs","end","next","resultsForRule","results","finalEdges","push","out","allEdges","allPassiveEdges","concat","allActiveEdges","edges","j","k","statistics","length","nrEdges","nrPassiveEdges","nrActiveEdges","PassiveEdge","ActiveEdge","rest","rules","text","parse","words","grammar","filter","chart","agenda","leftCornerFilter","addToChart","inference","rhs","slice","SRGS","oneof","eval","position","leftCorners","pop","active","passive","Prompt_Nomatch_Timeout","prompt","no_match","timeout","initial","states","entry","say","on","ENDSPEECH","ask","send","delay","id","nomatch","tokenize","sentence","trim","split","person","day","meeting_time","boolGrammar","string_bool","help_commands","dmMachine","init","CLICK","target","welcome","fill_appointment_info","RECOGNISED","cond","context","includes","recResult","MAXSPEECH","count","actions","assign","hist","type","who","indexOf","whole_day","time","confirm_time","value","listen","confirm_whole","created","maxspeech","help","guards","dmMachineTodo","dmMachineTimer","duration","promptAndAsk","invoke","src","_","nluRequest","onDone","event","intent","data","console","log","onError","set","confirmation","loadGrammar","dom","DOMParser","parseFromString","ActiveXObject","doc","XML","newDocument","loadXML","url","encodeURIComponent","request","XMLHttpRequest","open","responseXML","parseXML","getElementsByTagName","getAttribute","xrules","r","xrule","processRuleExpansions","xitems","childNodes","rule","nodeType","textContent","nodeName","uri","repeat","parseInt","getRuleObj","input","gram","result","command","action","object","dmMachineHome","task","perform","fetch","Request","proxyurl","method","headers","body","then","json","dmMachineMain","statement","check_intent","appointment","item","timer","smart_home","cancel","_context","inspect","iframe","machine","Machine","dm","asrtts","idle","LISTEN","SPEAK","ttsAgenda","recognising","exit","ASRRESULT","progress","match","speaking","recLogResult","test","logIntent","nluData","ReactiveButton","props","state","matches","className","style","animation","App","useSpeechSynthesis","onEnd","speak","useSpeechRecognition","onResult","stop","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","changeColour","document","background","ttsStart","effect","ttsCancel","current","onClick","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.cfb940c4.chunk.js","sourcesContent":["//\r\n//  srgs.js\r\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\r\n//\r\n/*\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU Lesser General Public License as published \r\n  by the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n  \r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n  \r\n  You should have received a copy of the GNU General Public License\r\n  and the GNU Lesser General Public License along with this program.  \r\n  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// encoding SRGS grammars in javascript\r\n\r\nexport function Grammar(root) {\r\n    this.$root = root;\r\n    \r\n    this.VOID = [OneOf([])];\r\n    this.NULL = [];\r\n    this.GARBAGE = []; \r\n    \r\n    this.$check = function() {\r\n      for (var i in this) {\r\n        if (i !== \"$root\" && i !== \"$check\") {\r\n      try {\r\n        checkSequenceExpansion(this[i]);\r\n      } catch(err) {\r\n        throwRuleError(\"When checking grammar rule '\" + i + \"'\", err);\r\n      }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  export function WordSet(str) {\r\n    var words = str.split(/ +/);\r\n    var set = {};\r\n    for (var i in words) {\r\n      set[words[i]] = true;\r\n    }\r\n    return set;\r\n  }\r\n  \r\n  //////////////////////////////////////////////////////////////////////\r\n  // rule expansion constructors\r\n  \r\n  // sequences are ordinary arrays\r\n  export function Sequence(seq) {\r\n    return seq;\r\n  }\r\n  \r\n  export function Ref(ref) {\r\n    return new RefClass(ref);\r\n  }\r\n  \r\n  export function Tag(tag) {\r\n    return new TagClass(tag);\r\n  }\r\n  \r\n  export function OneOf(alternatives) {\r\n    return new OneOfClass(alternatives);\r\n  }\r\n  \r\n  export function Repeat(min, max, sequence) {\r\n    return new RepeatClass(min, max, sequence);\r\n  }\r\n  \r\n  export function Optional(sequence) {\r\n    return new RepeatClass(0, 1, sequence);\r\n  }\r\n  \r\n  //////////////////////////////////////////////////////////////////////\r\n  // rule expansion classes\r\n  \r\n  export function RefClass(ruleref) {\r\n    this.content = ruleref;\r\n    this._string = \"$\" + ruleref;\r\n    this.toString = function toString() {return this._string}\r\n  }\r\n      \r\n  export function TagClass(tag) {\r\n    this.content = tag;\r\n    this._string = \"{\" + tag + \"}\";\r\n    this.toString = function toString() {return this._string}\r\n  }\r\n  \r\n  export function OneOfClass(alternatives) {\r\n    this.content = alternatives;\r\n    this._string = \"(\" + alternatives.join(\"|\") + \")\";\r\n    this.toString = function toString() {return this._string}\r\n  }\r\n  \r\n  export function RepeatClass(min, max, sequence) {\r\n    this.min = min;\r\n    this.max = max;\r\n    this.content = sequence;\r\n    this._string = this.content + \"<\" + this.min + \"-\" + (this.max==Infinity ? \"\" : this.max) + \">\"\r\n    this.toString = function toString() {return this._string}\r\n  }\r\n  \r\n  //////////////////////////////////////////////////////////////////////\r\n  // checking rule expansions\r\n  \r\n  export function throwRuleError(message, error) {\r\n    if (error == undefined) {\r\n      throw TypeError(message);\r\n    } else {\r\n      throw TypeError(message + \"; \" + error.message);\r\n    }\r\n  }\r\n  \r\n  export function checkSequenceExpansion(sequence) {\r\n    try {\r\n      if (sequence.constructor !== Array) {\r\n        throwRuleError(\"Expected Array, found \" + sequence.constructor.name);\r\n      }\r\n      for (var i in sequence) {\r\n        if (sequence[i].constructor == Array) {\r\n      checkSequenceExpansion(sequence[i]);\r\n        } else if (sequence[i].constructor != String) {\r\n      sequence[i].checkExpansion();\r\n        }\r\n      }\r\n    } catch(err) {\r\n      throwRuleError(\"When checking sequence expansion\", err);\r\n    }\r\n  };\r\n  \r\n  RefClass.prototype.checkExpansion = function checkExpansion() {\r\n    if (this.content.constructor !== String) {\r\n      throwRuleError(\"When checking Ref content; Expected String, found \" + this.content.constructor.name);\r\n    }\r\n  };\r\n  \r\n  TagClass.prototype.checkExpansion = function checkExpansion() {\r\n    if (this.content.constructor !== String) {\r\n        throwRuleError(\"When checking Tag content; Expected String, found \" + this.content.constructor.name);\r\n    }\r\n  };\r\n  \r\n  OneOfClass.prototype.checkExpansion = function checkExpansion() {\r\n    try {\r\n      if (this.content.constructor !== Array) {\r\n        throwRuleError(\"Expected Array, found \" + this.content.constructor.name);\r\n      }\r\n      for (var i in this.content) {\r\n        checkSequenceExpansion(this.content[i]);\r\n      }\r\n    } catch(err) {\r\n      throwRuleError(\"When checking OneOf content\", err);\r\n    }\r\n  };\r\n  \r\n  RepeatClass.prototype.checkExpansion = function checkExpansion() {\r\n    try {\r\n      if (this.min.constructor !== Number || this.max.constructor !== Number) {\r\n        throwRuleError(\"Expected min/max to be Number, found \" + this.min.constructor.name + \"/\" + this.max.constructor.name);\r\n      }\r\n      if (!(0 <= this.min && this.min <= this.max)) {\r\n        throwRuleError(\"Expected 0 <= min <= max, found \" + this.min + \"/\" + this.max);\r\n      }\r\n      checkSequenceExpansion(this.content);\r\n    } catch(err) {\r\n      throwRuleError(\"When checking Repeat content\", err);\r\n    }\r\n  };","//\r\n//  chartparser.js\r\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\r\n//\r\n/*\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU Lesser General Public License as published \r\n  by the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n  \r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n  \r\n  You should have received a copy of the GNU General Public License\r\n  and the GNU Lesser General Public License along with this program.  \r\n  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/* Mods by Torbjörn\r\n- Removed the toString() method from Object. Why does it still work?\r\n- Added a text variable (similar to rules). See \r\n*/\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// a logging function\r\n//  - uncomment if you want to debug the parsing process\r\nfunction LOG(str) {\r\n    //console.log(\"\" + str);\r\n  }\r\n  \r\n  import * as SRGS from './srgs'\r\n  \r\n  //////////////////////////////////////////////////////////////////////\r\n  // we need to be able to clone objects between different edges\r\n  // borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\r\n  function clone(obj){\r\n    if (obj == null || typeof(obj) != 'object') {\r\n      return obj;\r\n    }\r\n    var temp = new obj.constructor(); \r\n    for (var key in obj) {\r\n      temp[key] = clone(obj[key]);\r\n    }\r\n    return temp;\r\n  }\r\n  \r\n  \r\n  function isEmpty(ob){\r\n     for (var i in ob) { if(ob.hasOwnProperty(i)) {return false;}}\r\n    return true;\r\n  }\r\n  \r\n  //////////////////////////////////////////////////////////////////////\r\n  // parse chart\r\n  // conceptually this is a set of edges, but it is optimized\r\n  function Chart(numberOfWords) {\r\n    this.numberOfWords = numberOfWords;\r\n    this.passives = new Array(numberOfWords);\r\n    this.actives = new Array(numberOfWords);\r\n    for (var i = 0; i <= numberOfWords; i++) {\r\n      this.passives[i] = {};\r\n      this.actives[i] = {};\r\n    }\r\n  \r\n    // Chart.add(edge)\r\n    // add the edge to the chart, return true if the chart was changed \r\n    // (i.e. if the chart didn't already contain the edge)\r\n    this.add = function add(edge) {\r\n      var subchart, cat;\r\n      if (edge.isPassive) {\r\n        subchart = this.passives[edge.start];\r\n        cat = edge.lhs;\r\n      } else {\r\n        subchart = this.actives[edge.end];\r\n        cat = edge.next.content;\r\n      }\r\n      if (!(cat in subchart)) {\r\n        subchart[cat] = {};\r\n      }\r\n      if (edge in subchart[cat]) {\r\n        return false;\r\n      } else {\r\n        subchart[cat][edge] = edge;\r\n        return true;\r\n      }\r\n    }\r\n  \r\n    // Chart.resultsForRule(lhs, start, end)\r\n    // return all parse results for the given lhs, start, and end\r\n    //  - start, end are optional; defaults to 0, numberOfWords\r\n    this.resultsForRule = function resultsForRule(lhs, start=0, end=numberOfWords) {\r\n      start = start || 0;\r\n      end = end || numberOfWords;\r\n      var results = [];\r\n      var finalEdges = this.passives[start][lhs];\r\n      for (var i in finalEdges) {\r\n        if (finalEdges[i].end == end) {\r\n      results.push(finalEdges[i].out);\r\n        }\r\n      }\r\n      return results;\r\n    }\r\n    \r\n    // Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\r\n    // return an array of all (passive/active) edges in the chart\r\n    this.allEdges = function allEdges() {\r\n      return this.allPassiveEdges().concat(this.allActiveEdges());\r\n    }\r\n    this.allPassiveEdges = function allPassiveEdges() {\r\n      var edges = [];\r\n      for (var i in this.passives) \r\n        for (var j in this.passives[i]) \r\n      for (var k in this.passives[i][j])\r\n        edges.push(this.passives[i][j][k]);\r\n      return edges;\r\n    }\r\n    this.allActiveEdges = function allActiveEdges() {\r\n      var edges = [];\r\n      for (var i in this.actives) \r\n        for (var j in this.actives[i]) \r\n      for (var k in this.actives[i][j])\r\n        edges.push(this.actives[i][j][k]);\r\n      return edges;\r\n    }\r\n  \r\n    // Chart.statistics()\r\n    // return the number of edges in the chart\r\n    this.statistics = function statistics() {\r\n      var passives = this.allPassiveEdges().length;\r\n      var actives = this.allActiveEdges().length;\r\n      return {nrEdges: passives+actives, nrPassiveEdges: passives, nrActiveEdges: actives};\r\n    }\r\n  }\r\n  \r\n  \r\n  //////////////////////////////////////////////////////////////////////\r\n  // parse edges: passive and active\r\n  \r\n  function PassiveEdge(start, end, lhs, out) {\r\n    this.start = start;\r\n    this.end = end;\r\n    this.lhs = lhs;\r\n    this.out = out;\r\n    this.isPassive = true;\r\n  \r\n    var str = \"[\" + start + \"-\" + end + \"] $\" + lhs + \" := \" + out;\r\n    this._string = str;\r\n    this.toString = function toString() {return this._string;} \r\n  }\r\n  \r\n  function ActiveEdge(start, end, lhs, next, rest, out, rules, text) {\r\n    this.start = start;\r\n    this.end = end;\r\n    this.lhs = lhs;\r\n    this.next = next;\r\n    this.rest = rest;\r\n    this.out = out;\r\n    this.rules = rules;\r\n    this.text = text;\r\n    this.isPassive = false;\r\n  \r\n    var str = \"<\" + start + \"-\" + end + \"> $\" + lhs + \" -> \" + next + \r\n      \", \" + rest + \" := \" + out + \" <- \" + rules;\r\n    this._string = str;\r\n    this.toString = function toString() {return this._string;} \r\n  }\r\n  \r\n  \r\n  //////////////////////////////////////////////////////////////////////\r\n  // the main parsing function: a simple top-down chartparser\r\n  //  - 'words' is an array of strings\r\n  //  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\r\n  //  - 'root' is the starting category (a string)\r\n  //    if unspecified, use the '$root' property of the grammar\r\n  //  - 'filter' is an optional left-corner filter \r\n  //    (a mapping from categories/rule-refs to words)\r\n  //    if specified, it is used when predicting new edges\r\n  // returns the final chart\r\n  export function parse(words, grammar, root, filter) {\r\n    if (!root) {\r\n      root = grammar.$root;\r\n    }\r\n    var chart = new Chart(words.length);\r\n    var agenda = [];\r\n  \r\n    var leftCornerFilter;\r\n    if (filter == undefined) {\r\n      leftCornerFilter = function() {return true};\r\n    } else {\r\n      leftCornerFilter = function leftCornerFilter(ruleref, position) {\r\n        var leftCorners = filter[ruleref];\r\n        return leftCorners ? words[position] in leftCorners : true;\r\n      }\r\n    }\r\n    \r\n    // add an edge to the chart and the agenda, if it does not already exist\r\n    function addToChart(inference, start, end, lhs, rhs, out, rules, text) {\r\n      var edge;\r\n      if (rhs.length > 0) {\r\n        var next = rhs[0];\r\n        var rest = rhs.slice(1);\r\n        switch (next.constructor) {\r\n      \r\n        case Array:\r\n      // the next symbol is a sequence\r\n      addToChart(inference+\",SEQUENCE\", start, end, lhs, next.concat(rest), out, rules, text);\r\n      return;\r\n      \r\n        case SRGS.RepeatClass:\r\n      // the next symbol is a repetition\r\n      var min = next.min;\r\n      var max = next.max;\r\n      // skip repeat \r\n      if (min <= 0) {\r\n        addToChart(inference+\",SKIP\", start, end, lhs, rest, out, rules, text);\r\n      }\r\n      // repeat \r\n      if (max > 0) {\r\n        var content = next.content;\r\n        var rhs = (max==1 ? [content] : [content, SRGS.Repeat(min ? min-1 : min, max-1, content)]);\r\n        addToChart(inference+\",REPEAT\", start, end, lhs, rhs.concat(rest), out, rules, text);\r\n      }\r\n      return;\r\n      \r\n        case SRGS.OneOfClass:\r\n      // the next symbol is a disjunction\r\n      var oneof = next.content;\r\n      for (var i in oneof) {\r\n        var rhs = oneof[i].concat(rest);\r\n        addToChart(inference+\",ONEOF\", start, end, lhs, rhs, out, rules, text);\r\n      } \r\n      return;\r\n      \r\n        case SRGS.TagClass:\r\n      // the next symbol is a semantic action\r\n      out = clone(out);\r\n      rules = clone(rules);\r\n      eval(next.content);\r\n      addToChart(inference+\",TAG\", start, end, lhs, rest, out, rules, text);\r\n      return;\r\n        }\r\n  \r\n        edge = new ActiveEdge(start, end, lhs, next, rest, out, rules, text);\r\n      } else {\r\n        edge = new PassiveEdge(start, end, lhs, out);\r\n      }\r\n      \r\n      // try to add the edge; if successful, also add it to the agenda\r\n      if (chart.add(edge)) {\r\n        LOG(\"+ \" + inference + \": \" + edge);\r\n        agenda.push(edge);\r\n      }\r\n    }\r\n    \r\n    // seed the agenda with the starting rule\r\n    addToChart(\"INIT\", 0, 0, root, grammar[root], {}, {}, {});\r\n    \r\n    // main loop\r\n    while (agenda.length > 0) {\r\n      var edge = agenda.pop();\r\n      var start= edge.start;\r\n      var end  = edge.end;\r\n      var lhs  = edge.lhs;\r\n      var next = edge.next;\r\n      LOG(edge);\r\n  \r\n      if (edge.isPassive) {\r\n        // combine\r\n        var actives = chart.actives[start][lhs];\r\n        for (var i in actives) {\r\n      var active = actives[i];\r\n      var rules = clone(active.rules);\r\n      var text = active.text;\r\n      text[edge.lhs] = words.slice(start, end).join(\" \");\r\n      if (typeof edge.out == 'object' && isEmpty(edge.out)) {\r\n          rules[edge.lhs] = text[edge.lhs];\r\n      } else {\r\n          rules[edge.lhs] = clone(edge.out);\r\n      }\r\n      addToChart(\"COMBINE\", active.start, end, active.lhs, active.rest, active.out, rules, text);\r\n        }\r\n  \r\n      } else if (next.constructor == SRGS.RefClass) {\r\n        var ref = next.content;\r\n        // combine\r\n        var passives = chart.passives[end][ref];\r\n        for (var i in passives) {\r\n      var passive = passives[i];\r\n      var rules = clone(edge.rules);\r\n      var text = edge.text;\r\n      rules[passive.lhs] = clone(passive.out);\r\n      text[passive.lhs] = passive.text;\r\n      addToChart(\"COMBINE\", start, passive.end, lhs, edge.rest, edge.out, rules, text);\r\n        }\r\n        // predict\r\n        if (ref in grammar) {\r\n      if (leftCornerFilter(ref, end)) {\r\n        addToChart(\"PREDICT\", end, end, ref, grammar[ref], {}, {}, {});\r\n      }\r\n        }\r\n  \r\n      } else if (next == words[end]) {\r\n        // scan\r\n        addToChart(\"SCAN\", start, end+1, lhs, edge.rest, edge.out, edge.rules, edge.text);\r\n      }\r\n    }\r\n  \r\n    return chart;\r\n  }","import { MachineConfig, send, assign, actions, Machine, interpret, createMachine } from \"xstate\";\r\nimport {say, listen} from \"./index\";\r\n\r\nexport function Prompt_Nomatch_Timeout(prompt: string, no_match:string, timeout=5000): MachineConfig<SDSContext, any, SDSEvent> {\r\n    return ({\r\n\tinitial: 'prompt',\r\n\tstates: {\r\n            prompt: {\r\n                entry: say(prompt),\r\n                on: { ENDSPEECH: 'ask' }\r\n            },\r\n            ask: {\r\n                entry: [send('LISTEN'), send('MAXSPEECH', {delay: timeout , id: 'timeout'})]\r\n            },\r\n            nomatch: {\r\n                entry: say(no_match),\r\n                on: { ENDSPEECH: \"prompt\" }\r\n            }}})\r\n}\r\n\r\nexport function prompt(prompt:string): MachineConfig<SDSContext, any, SDSEvent> {\r\n    return ({\r\n        initial: 'prompt',\r\n\t    states: {\r\n            prompt: {\r\n                entry: say(prompt)\r\n            }\r\n        }})}\r\nconst tokenize = function (sentence: string) {\r\n    return sentence.trim().split(\" \");\r\n};\r\n\r\nconst grammar: { [index: string]: { person?: string, day?: string, meeting_time?: string } } = {\r\n    //names\r\n    \"John\": { person: \"John Appleseed\" }, \r\n    \"Bob\": { person: \"Bob Marley\" }, \r\n    \"Bill\": { person: \"Bill Gates\" }, \r\n    \"Charlie\": { person: \"Charlie Spencer\" }, \r\n    \"Angela\": { person: \"Angela Martin\" }, \r\n    \"Michael\": { person: \"Michael Scott\" }, \r\n    \"Pam\": { person: \"Pam Beesly\" }, \r\n    \"Jim\": { person: \"Jim Halpert\" }, \r\n    \"Dwight\": { person: \"Dwight Schrut\" }, \r\n    \"Creed\": { person: \"Creed Bratton\" }, \r\n    \"Toby\": { person: \"Toby Flenderson\" }, \r\n    \r\n    //day\r\n    \"Saturday\": { day: \"Saturday\" },\r\n    \"Sunday\": { day: \"Sunday\" },\r\n    \"Monday\": { day: \"Monday\" },\r\n    \"Tuesday\": { day: \"Tuesday\" },\r\n    \"Wednesday\": { day: \"Wednesday\" },\r\n    \"Thursday\": { day: \"Thursday\" },\r\n    \"Friday\": { day: \"Friday\" },\r\n    \"on Saturday\": { day: \"Saturday\" },\r\n    \"on Sunday\": { day: \"Sunday\" },\r\n    \"on Monday\": { day: \"Monday\" },\r\n    \"on Tuesday\": { day: \"Tuesday\" },\r\n    \"on Wednesday\": { day: \"Wednesday\" },\r\n    \"on Thursday\": { day: \"Thursday\" },\r\n    \"on Friday\": { day: \"Friday\" },\r\n\r\n    //time\r\n    \"1\": { meeting_time: \"one\" },\r\n    \"2\": { meeting_time: \"two\" },\r\n    \"3\": { meeting_time: \"three\" },\r\n    \"4\": { meeting_time: \"four\" },\r\n    \"5\": { meeting_time: \"five\" },\r\n    \"6\": { meeting_time: \"six\" },\r\n    \"7\": { meeting_time: \"seven\" },\r\n    \"8\": { meeting_time: \"eight\" },\r\n    \"9\": { meeting_time: \"nine\" },\r\n    \"10\": { meeting_time: \"ten\" },\r\n    \"11\": { meeting_time: \"eleven\" },\r\n    \"12\": { meeting_time: \"twelve\" },\r\n    \"noon\": { meeting_time: \"twelve\" },\r\n    \"at 1\": { meeting_time: \"one\" },\r\n    \"at 2\": { meeting_time: \"two\" },\r\n    \"at 3\": { meeting_time: \"three\" },\r\n    \"at 4\": { meeting_time: \"four\" },\r\n    \"at 5\": { meeting_time: \"five\" },\r\n    \"at 6\": { meeting_time: \"six\" },\r\n    \"at 7\": { meeting_time: \"seven\" },\r\n    \"at 8\": { meeting_time: \"eight\" },\r\n    \"at 9\": { meeting_time: \"nine\" },\r\n    \"at 10\": { meeting_time: \"ten\" },\r\n    \"at 11\": { meeting_time: \"eleven\" },\r\n    \"at 12\": { meeting_time: \"twelve\" },\r\n    \"at noon\": { meeting_time: \"twelve\" }\r\n\r\n}\r\n\r\nconst boolGrammar: { [index: string]: { string_bool?: string}}={\r\n    \"yes\": {string_bool: 'yes'},\r\n    \"sure\": {string_bool: 'yes'},\r\n    \"of course\": {string_bool: 'yes'},\r\n    \"that works\": {string_bool: 'yes'},\r\n    \"yeah\": {string_bool: 'yes'},\r\n    \"okay\": {string_bool: 'yes'},\r\n    \"OK\": {string_bool: 'yes'},\r\n    \"no problem\": {string_bool: 'yes'},\r\n    \"absolutely\": {string_bool: 'yes'},\r\n\r\n    \"nope\": {string_bool: 'no'},\r\n    \"no\": {string_bool: 'no'},\r\n    \"no way\": {string_bool: 'no'},\r\n    \"not at all\": {string_bool: 'no'},\r\n    \"impossible\": {string_bool: 'no'},\r\n    \"not really\": {string_bool: 'no'},\r\n    \"not sure\": {string_bool: 'no'},\r\n}\r\n\r\nconst help_commands = [\"help\", \"I don't know\", \"I don't understand\", \"help me\", \"I need help\", \"what does this mean\", \"wait what\", \"no wait\", \"what do you mean\", \"what the hell\"]\r\n\r\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\r\n    initial: 'welcome',\r\n    id: 'appointment',\r\n    states: {\r\n        init: {\r\n            on: {\r\n                CLICK: {\r\n                    target:'welcome',\r\n                }\r\n            }\r\n        },\r\n        welcome: {\r\n            ...prompt(\"Let's create an appointment\"),\r\n            on: { ENDSPEECH: \"fill_appointment_info\" }\r\n        },\r\n        fill_appointment_info:{\r\n            initial: 'who',\r\n            on: { \r\n                RECOGNISED: {\r\n                    target: 'help',\r\n                    cond: (context) => help_commands.includes(context.recResult)\r\n                },\r\n                MAXSPEECH: [{ \r\n                    cond: (context) => context.count < 3,\r\n                    target: 'maxspeech'\r\n            },{\r\n                cond: (context) => context.count == null,\r\n                actions: assign((context)=>{return {count: Number(0)}}),\r\n                target: 'maxspeech'\r\n            }],\r\n            },\r\n            states:{\r\n                hist: {type: 'history'},\r\n                who: {\r\n                    ...Prompt_Nomatch_Timeout(\"Who are you meeting with?\", \"Sorry I don't know them\", 7000), //more delay because it takes some extra time to say everything at once\r\n                    on: {\r\n                        RECOGNISED: [{\r\n                            cond: (context) =>  context.recResult.includes(\"at\") && context.recResult.includes(\"on\") && tokenize(context.recResult).indexOf(\"at\") == 1 && tokenize(context.recResult).indexOf(\"on\") == 3 && \"person\" in (grammar[tokenize(context.recResult)[0]] || {}) &&  \"meeting_time\" in (grammar[tokenize(context.recResult)[2]] || {}) && \"day\" in (grammar[tokenize(context.recResult)[4]] || {}),\r\n                            actions: [assign((context) => { return { person: tokenize(context.recResult)[0] }}),assign((context) => { return { day: tokenize(context.recResult)[4] }}),assign((context) => { return { meeting_time: tokenize(context.recResult)[2] }})],\r\n                            target: \"confirm_time\"\r\n                        },{\r\n                            cond: (context) =>  context.recResult.includes(\"at\") && context.recResult.includes(\"on\") && \"person\" in (grammar[tokenize(context.recResult)[0]] || {}) &&  \"meeting_time\" in (grammar[tokenize(context.recResult)[4]] || {}) && \"day\" in (grammar[tokenize(context.recResult)[2]] || {}),\r\n                            actions: [assign((context) => { return { person: tokenize(context.recResult)[0] }}),assign((context) => { return { day: tokenize(context.recResult)[2] }}),assign((context) => { return { meeting_time: tokenize(context.recResult)[4] }})],\r\n                            target: \"confirm_time\"\r\n                        },{\r\n                            cond: (context) => context.recResult.includes(\"on\") && \"person\" in (grammar[tokenize(context.recResult)[0]] || {})  && \"day\" in (grammar[tokenize(context.recResult)[2]] || {}),\r\n                            actions: [assign((context) => { return { person: tokenize(context.recResult)[0] }}),assign((context) => { return { day: tokenize(context.recResult)[2] }})],\r\n                            target: \"whole_day\"\r\n                        },{\r\n                            cond: (context) => context.recResult.includes(\"at\") && \"person\" in (grammar[tokenize(context.recResult)[0]] || {})  && \"meeting_time\" in (grammar[tokenize(context.recResult)[2]] || {}),\r\n                            actions: [assign((context) => { return { person: tokenize(context.recResult)[0] }}),assign((context) => { return { meeting_time: tokenize(context.recResult)[2] }})],\r\n                            target: \"day\"\r\n                        },{\r\n                            cond: (context) => \"person\" in (grammar[context.recResult] || {}),\r\n                            actions: assign((context) => { return { person: grammar[context.recResult].person } }),\r\n                            target: \"day\"\r\n                        },{\r\n                            cond: (context) => !(help_commands.includes(context.recResult)),\r\n                            target: \".nomatch\" }]\r\n                    },\r\n                    \r\n                },\r\n                day: {\r\n                    ...Prompt_Nomatch_Timeout(`OK . what day is your meeting?`, \"Sorry I don't understand\"),\r\n                    on: {\r\n                        RECOGNISED: [{\r\n                            cond: (context) =>  context.recResult.includes(\"at\") && context.recResult.includes(\"on\") && tokenize(context.recResult).indexOf(\"at\") == 2 &&  \"meeting_time\" in (grammar[tokenize(context.recResult)[3]] || {}) && \"day\" in (grammar[tokenize(context.recResult)[1]] || {}),\r\n                            actions: [assign((context) => { return { person: tokenize(context.recResult)[0] }}),assign((context) => { return { day: tokenize(context.recResult)[4] }}),assign((context) => { return { meeting_time: tokenize(context.recResult)[2] }})],\r\n                            target: \"confirm_time\"\r\n                        },{\r\n                            cond: (context) => context.meeting_time != null && \"day\" in (grammar[context.recResult] || {}),\r\n                            actions: [assign((context) => { return { day: context.recResult } })],\r\n                            target: \"confirm_time\"\r\n                        },{\r\n                            cond: (context) => \"day\" in (grammar[tokenize(context.recResult)[1]] || {}) && \"whole\" in tokenize(context.recResult) && \"day\" in tokenize(context.recResult),\r\n                            actions: assign((context) => { return { day: grammar[context.recResult].day } }),\r\n                            target: \"confirm_whole\"\r\n\r\n                        },{\r\n                            cond: (context) => \"day\" in (grammar[context.recResult] || {}),\r\n                            actions: assign((context) => { return { day: grammar[context.recResult].day } }),\r\n                            target: \"whole_day\"\r\n\r\n                        },\r\n                        { cond: (context) => !(help_commands.includes(context.recResult)),\r\n                            target: \".nomatch\" }]\r\n                    },\r\n                },\r\n                whole_day: {\r\n                    ...Prompt_Nomatch_Timeout(\"OK. Will it take the whole day?\", \"Sorry I don't understand\"),\r\n                    on: {\r\n                        RECOGNISED: [{\r\n                            cond: (context) => \"string_bool\" in (boolGrammar[context.recResult] || {}) && boolGrammar[context.recResult].string_bool === 'yes',\r\n                            actions: assign((context) => { return { string_bool: boolGrammar[context.recResult].string_bool } }),\r\n                            target: \"confirm_whole\"\r\n                        },{\r\n                            cond: (context) => \"string_bool\" in (boolGrammar[context.recResult] || {}) && boolGrammar[context.recResult].string_bool === 'no',\r\n                            actions: assign((context) => { return { string_bool: boolGrammar[context.recResult].string_bool } }),\r\n                            target: \"time\"\r\n                        },{\r\n                            cond: (context) => !(help_commands.includes(context.recResult)),\r\n                            target: \".nomatch\" }]\r\n                    },\r\n                },\r\n                time: {\r\n                    ...Prompt_Nomatch_Timeout(\"OK. what time is your meeting?\",\"sorry i dont understand\"),\r\n                    on: {\r\n                        RECOGNISED: [{\r\n                            cond: (context) => \"meeting_time\" in (grammar[context.recResult] || {}),\r\n                            actions: assign((context) => { return { meeting_time: grammar[context.recResult].meeting_time } }),\r\n                            target: \"confirm_time\"\r\n                        },{ \r\n                            cond: (context) => !(help_commands.includes(context.recResult)),\r\n                            target: \".nomatch\" }]\r\n                    },\r\n                },\r\n                confirm_time:{\r\n                    initial: \"prompt\",\r\n                    on: {\r\n                        RECOGNISED: [{\r\n                            cond: (context) => \"string_bool\" in (boolGrammar[context.recResult] || {}) && boolGrammar[context.recResult].string_bool === 'yes',\r\n                            actions: assign((context) => { return { string_bool: boolGrammar[context.recResult].string_bool } }),\r\n                            target: \"created\"\r\n                        },{\r\n                            cond: (context) => \"string_bool\" in (boolGrammar[context.recResult] || {}) && boolGrammar[context.recResult].string_bool === 'no',\r\n                            actions: assign((context) => { return { string_bool: boolGrammar[context.recResult].string_bool } }),\r\n                            target: \"who\"\r\n                        },\r\n                        { \r\n                            cond: (context) => !(help_commands.includes(context.recResult)),\r\n                            target: \".nomatch\" }]\r\n                        },\r\n                        states: {\r\n                            prompt: {\r\n                                entry: send((context) => ({\r\n                                    type: \"SPEAK\",\r\n                                    value: `OK. do you want me to create an appointment with ${context.person} on ${context.day} at ${context.meeting_time}?`})),\r\n                                on: { ENDSPEECH: \"ask\" }\r\n                            },\r\n                        ask: {\r\n                            entry: listen()\r\n                        },\r\n                        nomatch: {\r\n                            entry: say(\"Sorry I don't understand\"),\r\n                            on: { ENDSPEECH: \"prompt\" }\r\n                        }\r\n                    }\r\n\r\n                },\r\n                confirm_whole: {\r\n                    initial: \"prompt\",\r\n                    on: {\r\n                        RECOGNISED: [{\r\n                            cond: (context) => \"string_bool\" in (boolGrammar[context.recResult] || {}) && boolGrammar[context.recResult].string_bool === 'yes',\r\n                            actions: assign((context) => { return { string_bool: boolGrammar[context.recResult].string_bool } }),\r\n                            target: \"created\"\r\n                        },{\r\n                            cond: (context) => \"string_bool\" in (boolGrammar[context.recResult] || {}) && boolGrammar[context.recResult].string_bool === 'no',\r\n                            actions: assign((context) => { return { string_bool: boolGrammar[context.recResult].string_bool } }),\r\n                            target: \"who\"\r\n                        },\r\n                        { \r\n                            cond: (context) => !(help_commands.includes(context.recResult)),\r\n                            target: \".nomatch\" }]\r\n                        },\r\n                        states: {\r\n                            prompt: {\r\n                                entry: send((context) => ({\r\n                                    type: \"SPEAK\",\r\n                                    value: `OK. do you want me to create an appointment with ${context.person} on ${context.day} for the whole day?`\r\n                                })),\r\n                                on: { ENDSPEECH: \"ask\" }\r\n                            },\r\n                        ask: {\r\n                            entry: listen()\r\n                        },\r\n                        nomatch: {\r\n                            entry: say(\"Sorry I don't understand\"),\r\n                            on: { ENDSPEECH: \"prompt\" }\r\n                        }\r\n                    }\r\n\r\n                },\r\n    \r\n        created: {\r\n            ...prompt(\"Your appointment has been created\"),\r\n            on: {ENDSPEECH: \"#root.dm.welcome\"}, //goes back to the main menu\r\n        }\r\n    }},\r\n    maxspeech:{\r\n        ...prompt(\"I will repeat\"),\r\n\r\n        on: {\r\n            'ENDSPEECH': {\r\n                actions: assign((context)=> { return {count: context.count + 1 }}),\r\n                target: 'fill_appointment_info.hist'\r\n            }\r\n        }\r\n  \r\n    },\r\n    help:{\r\n        ...prompt(\"You are a big boy, you need no help\"),\r\n        on: {'ENDSPEECH': 'fill_appointment_info.hist'}\r\n    },\r\n    guards:{\r\n        \r\n    }\r\n    }})\r\n","import { MachineConfig} from \"xstate\";\r\n\r\nimport {say} from \"./index\";\r\n\r\n\r\nexport const dmMachineTodo: MachineConfig<SDSContext, any, SDSEvent> = ({\r\n    initial: 'welcome',\r\n    states: {\r\n        welcome: {\r\n            initial: \"prompt\",\r\n            states: {\r\n                prompt: { \r\n                    entry: say(\"Welcome to your to do items. You have nothing to do. so, bye bye.\") }\r\n            }\r\n        }\r\n    }\r\n})\r\n","import { MachineConfig, send, assign } from \"xstate\";\r\nimport {nluRequest} from \"./dmMain\";\r\nimport {promptAndAsk} from \"./index\";\r\n\r\n\r\nexport const dmMachineTimer: MachineConfig<SDSContext, any, SDSEvent> = ({\r\n    initial: 'welcome',\r\n    states: {\r\n        welcome: {\r\n            on: {\r\n            RECOGNISED: {\r\n                target: 'duration',\r\n                actions: assign((context) => { return { duration: context.recResult } }),\r\n                    }\r\n                },\r\n            ...promptAndAsk(\"For how long do you want to set the timer?\")\r\n        },\r\n        duration: {\r\n            invoke: {\r\n            id: 'timer',\r\n                    src: (context, _) => nluRequest(context.duration), \r\n                    onDone: {\r\n                        target: 'set',\r\n                        actions: [assign((_, event) => { return {intent: event.data.intent.name }}),\r\n                      (_:SDSContext, event:any) => console.log(event.data)]\r\n                    },\r\n            onError: {\r\n                        target: 'welcome',\r\n                        actions: (_,event) => console.log(event.data)\r\n                    }\r\n                }\r\n        },\r\n        set: {\r\n            entry: send('ENDSPEECH'),\r\n            on: {\r\n                ENDSPEECH: [\r\n                    { target: 'confirmation', cond: (context) => context.intent === 'time' },\r\n                    { target: 'nomatch' }]\r\n                }\r\n        },\r\n        confirmation:{\r\n            entry: send((context) => ({\r\n                type: \"SPEAK\",\r\n                value: `OK. time set ${context.duration}`\r\n            }))\r\n        },\r\n        nomatch:{\r\n            entry: send((context) => ({\r\n                type: \"SPEAK\",\r\n                value: `I don't understand. ${context.duration} doesn't seem like a time duration`\r\n            })),\r\n            on: { ENDSPEECH: \"welcome\" }\r\n        }\r\n    }\r\n})\r\n","//\r\n//  runparser.js\r\n//\r\n/*\r\n  The author or authors of this code dedicate any and all \r\n  copyright interest in this code to the public domain.\r\n*/\r\n\r\n\r\n// helper functions for the parser demo\r\n\r\nimport * as SRGS from './srgs'\r\n\r\nfunction getElement(id) {\r\n  return document.getElementById(id);\r\n}\r\n\r\nfunction appendElement(parent, element, text) {\r\n  var elem = document.createElement(element);\r\n  if (text)\r\n    elem.appendChild(document.createTextNode(text));\r\n  parent.appendChild(elem);\r\n  return elem\r\n}\r\n\r\nfunction runParser(input) {\r\n  var resultsDiv = getElement(\"results\");\r\n  resultsDiv.innerHTML = \"\";\r\n  var maybeFilter;\r\n  if (getElement(\"usefilter\") && getElement(\"usefilter\").checked) {\r\n    maybeFilter = filter;\r\n    appendElement(resultsDiv, \"EM\", \"Using left-corner filter\");\r\n  }\r\n  var startTime = new Date();\r\n  var parseChart = parse(input, grammar, grammar.$root, maybeFilter);\r\n  var parseTime = new Date() - startTime;\r\n  var parseResults = parseChart.resultsForRule(grammar.$root);\r\n  \r\n  console.log(parseResults[0]);\r\n  \r\n  if (parseResults) {\r\n    for (var i in parseResults) {\r\n        resultsDiv.innerHTML += display(parseResults[i],\"\");\r\n    }\r\n  } else {\r\n    appendElement(resultsDiv, \"P\", \"No results found!\");\r\n  }\r\n  \r\n/*\r\n  if (parseResults) { \r\n    var resultList = appendElement(resultsDiv, \"OL\");\r\n    for (var i in parseResults) \r\n      appendElement(resultList, \"LI\", JSON.stringify(parseResults[i]));\r\n  } else {\r\n    appendElement(resultsDiv, \"P\", \"No results found!\");\r\n  }\r\n*/\r\n  var statistics = parseChart.statistics()\r\n  appendElement(resultsDiv, \"P\", \"Chart size: \" + statistics.nrEdges + \" edges\" +\r\n\t\t\" (\" + statistics.nrPassiveEdges + \" passive)\");\r\n  appendElement(resultsDiv, \"P\", \"Parse time: \" + parseTime + \" ms\" + \r\n\t\t\" (\" + (parseTime / statistics.nrEdges).toFixed(2) + \" ms/edge)\");\r\n}\r\n\r\nfunction runWordParser() {\r\n  runParser(getElement(\"input\").value.split(/\\s+/));\r\n}\r\n\r\nfunction runCharacterParser() {\r\n  runParser(getElement(\"input\").value.split(\"\"));\r\n}\r\n\r\nexport function loadGrammar(str) {\r\n    var dom = parseXML(str);\r\n    var root = dom.getElementsByTagName(\"grammar\")[0].getAttribute(\"root\");\r\n    var grammar = new SRGS.Grammar(root);\r\n    var xrules = dom.getElementsByTagName(\"rule\");\r\n    for(var r=0; r < xrules.length; r++) {\r\n        var xrule = xrules[r];\r\n        var id = xrule.getAttribute(\"id\");\r\n        grammar[id] = processRuleExpansions(xrule);\r\n    }\r\n    return grammar;\r\n}\r\n\r\nfunction processRuleExpansions(xrule) {\r\n    var xitems = xrule.childNodes;\r\n    var rule = [];\r\n    for(var i=0; i < xitems.length; i++) {\r\n        if (xitems[i].nodeType == 3) {\r\n            var str = xitems[i].textContent.trim();\r\n            if (str != \"\") {\r\n                rule.push(str.split(/ +/));\r\n            }\r\n        } else if (xitems[i].nodeType == 1) {\r\n            if (xitems[i].nodeName == \"token\") {\r\n                rule.push(SRGS.Tag(xitems[i].textContent));\r\n            } else if (xitems[i].nodeName == \"ruleref\") {\r\n                var uri = xitems[i].getAttribute(\"uri\");\r\n                rule.push(SRGS.Ref(uri.slice(1)));\r\n            } else if (xitems[i].nodeName == \"tag\") {\r\n                rule.push(SRGS.Tag(xitems[i].textContent.trim()));\r\n            } else if (xitems[i].nodeName == \"one-of\") {\r\n                rule.push(SRGS.OneOf(processRuleExpansions(xitems[i])));\r\n            } else if (xitems[i].nodeName == \"item\") {\r\n                var repeat = xitems[i].getAttribute(\"repeat\");\r\n                if (!repeat) {\r\n                    rule.push(processRuleExpansions(xitems[i]));\r\n                } else {\r\n                    var r = repeat.split(\"-\");\r\n                    var min = parseInt(r[0]);\r\n                    var max = parseInt(r[1]);\r\n                    max = (max) ? max : Infinity;\r\n                    rule.push(SRGS.Repeat(min, max, processRuleExpansions(xitems[i])));\r\n                }\r\n            } else {\r\n                console.log(xitems[i]);\r\n            }\r\n        }\r\n    }\r\n\treturn rule;\r\n}\r\n\r\nfunction parseXML(text) {\r\n    if (typeof DOMParser != \"undefined\") {\r\n        // Mozilla, Firefox, and related browsers\r\n        return (new DOMParser()).parseFromString(text, \"application/xml\");\r\n    }\r\n    else if (typeof ActiveXObject != \"undefined\") {\r\n        // Internet Explorer.\r\n        var doc = XML.newDocument();  // Create an empty document\r\n        doc.loadXML(text);            // Parse text into it\r\n        return doc;                   // Return it\r\n    }\r\n    else {\r\n        // As a last resort, try loading the document from a data: URL\r\n        // This is supposed to work in Safari. Thanks to Manos Batsis and\r\n        // his Sarissa library (sarissa.sourceforge.net) for this technique.\r\n        var url = \"data:text/xml;charset=utf-8,\" + encodeURIComponent(text);\r\n        var request = new XMLHttpRequest();\r\n        request.open(\"GET\", url, false);\r\n        request.send(null);\r\n        return request.responseXML;\r\n    }\r\n};","export const grammar = `\r\n<grammar root=\"home\">\r\n    <rule id=\"home\">\r\n        <ruleref uri=\"#command\"/>\r\n        <tag>out.command= new Object(); out.command.object = rules.command.thing; out.command.action = rules.command.todo; </tag>\r\n    </rule>\r\n    <rule id=\"actions\"> \r\n        <one-of> \r\n            <item> open </item> \r\n            <item> close </item> \r\n        </one-of> \r\n    </rule>\r\n    <rule id=\"actions2\"> \r\n        <one-of> \r\n            <item> on </item> \r\n            <item> off </item> \r\n        </one-of> \r\n    </rule>\r\n   <rule id=\"objects\"> \r\n        <one-of> \r\n            <item> window </item> \r\n            <item> door </item> \r\n        </one-of> \r\n    </rule>\r\n    <rule id=\"objects2\"> \r\n        <one-of> \r\n            <item> light </item> \r\n            <item> lights <tag> out = 'light'; </tag></item>\r\n            <item> heat </item> \r\n            <item> AC <tag> out = 'air conditioning'; </tag></item> \r\n            <item> A C <tag> out = 'air conditioning'; </tag></item> \r\n            <item> air conditioning </item> \r\n        </one-of> \r\n    </rule>\r\n     \r\n    <rule id=\"command\">\r\n        <item repeat=\"0-\">please</item>\r\n            <one-of> \r\n                <item>\r\n                    <ruleref uri=\"#actions\"/>\r\n                    <tag>out.todo=rules.actions;</tag>\r\n                    the\r\n                    <ruleref uri=\"#objects\"/>\r\n                    <tag>out.thing=rules.objects;</tag>\r\n                </item> \r\n                <item>\r\n                    turn\r\n                    <ruleref uri=\"#actions2\"/>\r\n                    <tag>out.todo=rules.actions2;</tag>\r\n                    the\r\n                    <ruleref uri=\"#objects2\"/>\r\n                    <tag>out.thing=rules.objects2;</tag>\r\n                </item> \r\n                <item>\r\n                    turn the\r\n                    <ruleref uri=\"#objects2\"/>\r\n                    <tag>out.thing=rules.objects2;</tag> \r\n                    <ruleref uri=\"#actions2\"/>\r\n                    <tag>out.todo=rules.actions2;</tag> \r\n                </item> \r\n            </one-of> \r\n    </rule>\r\n</grammar>\r\n`","import { MachineConfig, send, assign } from \"xstate\";\r\nimport {say, listen} from \"./index\";\r\nimport { promptAndAsk } from \"./index\";\r\n\r\n\r\nimport { loadGrammar } from './runparser'\r\nimport { parse } from './chartparser'\r\nimport { grammar } from './grammars/homeGrammar'\r\n\r\n/* funnyGrammar test */\r\n// const gram = loadGrammar(grammar)\r\n// const input = \"to do is to be\"\r\n// const prs = parse(input.split(/\\s+/), gram)\r\n// const result = prs.resultsForRule(gram.$root)[0]\r\n// console.log(result) //accessed in the machine via ${result.quote.source} \r\n\r\nexport const getRuleObj = (input: string) => {\r\n    const gram = loadGrammar(grammar);\r\n    const prs = parse(input.split(/\\s+/), gram);\r\n    const result = prs.resultsForRule(gram.$root)[0]\r\n    const reply = \"action to perform is, \"+result.command.action+\". on object, \" + result.command.object;\r\n    return reply\r\n}\r\n\r\nexport const dmMachineHome: MachineConfig<SDSContext, any, SDSEvent> = ({\r\n    initial: 'welcome',\r\n    states: {\r\n        welcome: {\r\n            initial: \"prompt\",\r\n            on: { ENDSPEECH: \"task\" },\r\n            states: {\r\n                prompt: { entry: say(\"Welcome to Smart Home\") }\r\n            }\r\n        },\r\n        task: {\r\n            initial: \"prompt\",\r\n            on: {\r\n                RECOGNISED: {\r\n                    target: 'perform',\r\n                    actions: assign((context) => {return { rule: getRuleObj(context.recResult) } })\r\n                        }\r\n                    },\r\n            ...promptAndAsk(\"What would you like me to do?\")\r\n        },\r\n        perform: {\r\n            initial: \"prompt\",\r\n            states: {\r\n                prompt: { \r\n                    entry: send((context) => ({\r\n                        type: \"SPEAK\",\r\n                        value: `OK ${context.rule}.`\r\n                    }))\r\n                }\r\n            }\r\n        }\r\n    }\r\n})\r\n","import { MachineConfig, send, assign } from \"xstate\";\r\nimport { promptAndAsk } from \"./index\";\r\nimport { dmMachine } from \"./dmAppointment\";\r\nimport { dmMachineTodo } from \"./dmTodo\";\r\nimport { dmMachineTimer } from \"./dmTimer\";\r\nimport { dmMachineHome } from \"./dmSmartHome\";\r\n\r\nimport { loadGrammar } from './runparser'\r\nimport { parse } from './chartparser'\r\nimport { gramm } from './grammars/funnyGrammar'\r\n\r\n\r\n// RASA API\r\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\r\nconst rasaurl = \"https://dialogue-management.herokuapp.com/model/parse\";\r\nexport const nluRequest = (text: string) =>\r\n    fetch(new Request(proxyurl + rasaurl, {\r\n        method: 'POST',\r\n        headers: { 'Origin': 'http://maraev.me' }, // only required with proxy\r\n        body: `{\"text\": \"${text}\"}`\r\n    }))\r\n        .then(data => data.json());\r\n\r\nconst gram = loadGrammar(gramm)\r\nconst input = \"to do is to be\"\r\nconst prs = parse(input.split(/\\s+/), gram)\r\nconst result = prs.resultsForRule(gram.$root)[0]\r\n\r\nconsole.log(result) //accessed in the machine via ${result.quote.source} \r\n\r\nexport const dmMachineMain: MachineConfig<SDSContext, any, SDSEvent> = ({\r\n    initial: 'init',\r\n    states: {\r\n        init: {\r\n            on: {\r\n                CLICK: 'welcome'\r\n            }\r\n        },\r\n        welcome: {\r\n            on: {\r\n            RECOGNISED: {\r\n                target: 'statement',\r\n                actions: assign((context) => { return { statement: context.recResult } }),\r\n                    }\r\n                },\r\n            ...promptAndAsk(\"What would you like to do?\")\r\n        },\r\n        statement: {\r\n            invoke: {\r\n            id: 'nlu',\r\n                    src: (context, _) => nluRequest(context.statement), \r\n                    onDone: {\r\n                        target: 'check_intent',\r\n                        actions: [assign((_, event) => { return {intent: event.data.intent.name }}),\r\n                      (_:SDSContext, event:any) => console.log(event.data)]\r\n                    },\r\n                    onError: {\r\n                        target: 'welcome',\r\n                        actions: (_,event) => console.log(event.data)\r\n                    }\r\n                }\r\n        },\r\n        check_intent: {\r\n            entry: send('ENDSPEECH'),\r\n            on: {\r\n                ENDSPEECH: [\r\n                    { target: 'appointment', cond: (context) => context.intent === 'appointment' },\r\n                    { target: 'item', cond: (context) => context.intent === 'todo_item' },\r\n                    { target: 'timer', cond: (context) => context.intent === 'timer' },\r\n                    { target: 'smart_home', cond: (context) => context.intent === 'smart_home' },\r\n                    { target: 'welcome' }] \r\n                } \r\n        },\r\n        appointment: {\r\n           ...dmMachine \r\n        },\r\n        item: {\r\n            ...dmMachineTodo\r\n        },\r\n        timer: {\r\n            ...dmMachineTimer\r\n        },\r\n        smart_home: {\r\n            ...dmMachineHome\r\n        }\r\n    }\r\n})\r\n","export const gramm = `\r\n<grammar root=\"funny_quotes\">\r\n\r\n   <rule id=\"funny_quotes\">\r\n      <ruleref uri=\"#quote\"/>\r\n      <tag>out.quote = new Object(); out.quote.source=rules.quote.said_by;</tag>\r\n   </rule>\r\n\r\n   <rule id=\"quotes\">\r\n      <one-of>\r\n         <item>do be do be do<tag>out=\"Sinatra\";</tag></item>\r\n         <item>to be is to do<tag>out=\"Sartre\";</tag></item>\r\n         <item>to do is to be<tag>out=\"Socrates\";</tag></item>\r\n      </one-of>\r\n   </rule>\r\n\r\n   <rule id=\"quote\">\r\n      <ruleref uri=\"#quotes\"/>\r\n      <tag>out.said_by=rules.quotes;</tag>\r\n   </rule>\r\n   \r\n</grammar>\r\n    \r\n`","import \"./styles.scss\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { Action, Machine, assign, send, actions, State, MachineConfig } from \"xstate\";\r\nimport { useMachine, asEffect } from \"@xstate/react\";\r\nimport { inspect } from \"@xstate/inspect\";\r\nimport { dmMachineMain } from \"./dmMain\";\r\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\r\n// import { cancel } from \"xstate/lib/actionTypes\";\r\nconst {cancel} = actions\r\n\r\ninspect({\r\n    url: \"https://statecharts.io/inspect\",\r\n    iframe: false\r\n});\r\n\r\nexport function promptAndAsk(prompt: string): MachineConfig<SDSContext, any, SDSEvent> {\r\n    return ({\r\n\tinitial: 'prompt',\r\n\tstates: {\r\n            prompt: {\r\n                entry: say(prompt),\r\n                on: { ENDSPEECH: 'ask' }\r\n            },\r\n            ask: {\r\n\t\t        entry: send('LISTEN'),\r\n            }\r\n\t}})\r\n}\r\n\r\nexport function say(text: string): Action<SDSContext, SDSEvent> {\r\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\r\n}\r\n\r\nexport function listen(): Action<SDSContext, SDSEvent> {\r\n    return send('LISTEN')\r\n}\r\n\r\n\r\nconst machine = Machine<SDSContext, any, SDSEvent>({\r\n    id: 'root',\r\n    type: 'parallel',\r\n    states: {\r\n        dm: {\r\n            ...dmMachineMain\r\n        },\r\n        asrtts: {\r\n            initial: 'idle',\r\n            states: {\r\n                idle: {\r\n                    on: {\r\n                        LISTEN: 'recognising',\r\n                        SPEAK: {\r\n                            target: 'speaking',\r\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\r\n                        }\r\n                    }\r\n                },\r\n                recognising: {\r\n\t\t    initial: 'progress',\r\n                    entry: 'recStart',\r\n                    exit: 'recStop',\r\n                    on: {\r\n                        ASRRESULT: {\r\n                            actions: ['recLogResult',\r\n                                assign((_context, event) => { return { recResult: event.value } })],\r\n                            target: '.match'\r\n                        },\r\n                        RECOGNISED: {target:'idle',actions: [cancel('timeout'),  assign((context)=>{return {count: Number(0)}})]}, // target idel and actions cancel\r\n                        MAXSPEECH: 'idle'\r\n                    },\r\n                    states: {\r\n\t\t    \tprogress: {\r\n\t\t\t},\t    \t\t\t\t\t\r\n                        match: {\r\n                            entry: send('RECOGNISED'),\r\n                        },\r\n                    }\r\n                },\r\n                speaking: {\r\n                    entry: 'ttsStart',\r\n                    on: {\r\n                        ENDSPEECH: 'idle',\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n},\r\n    {\r\n        actions: {\r\n            recLogResult: (context: SDSContext) => {\r\n                /* context.recResult = event.recResult; */\r\n                console.log('<< ASR: ' + context.recResult);\r\n            },\r\n            test: () => {\r\n                console.log('test')\r\n            },\r\n            logIntent: (context: SDSContext) => {\r\n                /* context.nluData = event.data */\r\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\r\n            }\r\n        },\r\n    });\r\n\r\n\r\n\r\ninterface Props extends React.HTMLAttributes<HTMLElement> {\r\n    state: State<SDSContext, any, any, any>;\r\n}\r\nconst ReactiveButton = (props: Props): JSX.Element => {\r\n    switch (true) {\r\n        case props.state.matches({ asrtts: 'recognising' }):\r\n            return (\r\n                <button type=\"button\" className=\"glow-on-hover\"\r\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\r\n                    Listening...\r\n                </button>\r\n            );\r\n        case props.state.matches({ asrtts: 'speaking' }):\r\n            return (\r\n                <button type=\"button\" className=\"glow-on-hover\"\r\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\r\n                    Speaking...\r\n                </button>\r\n            );\r\n        default:\r\n            return (\r\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\r\n                    Click to start\r\n                </button >\r\n            );\r\n    }\r\n}\r\n\r\nfunction App() {\r\n    const { speak, cancel, speaking } = useSpeechSynthesis({\r\n        onEnd: () => {\r\n            send('ENDSPEECH');\r\n        },\r\n    });\r\n    const { listen, listening, stop } = useSpeechRecognition({\r\n        onResult: (result: any) => {\r\n            send({ type: \"ASRRESULT\", value: result });\r\n        },\r\n    });\r\n    const [current, send, service] = useMachine(machine, {\r\n        devTools: true,\r\n        actions: {\r\n            recStart: asEffect(() => {\r\n                console.log('Ready to receive a color command.');\r\n                listen({\r\n                    interimResults: false,\r\n                    continuous: true\r\n                });\r\n            }),\r\n            recStop: asEffect(() => {\r\n                console.log('Recognition stopped.');\r\n                stop()\r\n            }),\r\n            changeColour: asEffect((context) => {\r\n                console.log('Repainting...');\r\n                document.body.style.background = context.recResult;\r\n            }),\r\n            ttsStart: asEffect((context, effect) => {\r\n                console.log('Speaking...');\r\n                speak({ text: context.ttsAgenda })\r\n            }),\r\n            ttsCancel: asEffect((context, effect) => {\r\n                console.log('TTS STOP...');\r\n                cancel()\r\n            })\r\n            /* speak: asEffect((context) => {\r\n\t     * console.log('Speaking...');\r\n             *     speak({text: context.ttsAgenda })\r\n             * } */\r\n        }\r\n    });\r\n\r\n\r\n    return (\r\n        <div className=\"App\">\r\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nReactDOM.render(\r\n    <App />,\r\n    rootElement);"],"sourceRoot":""}